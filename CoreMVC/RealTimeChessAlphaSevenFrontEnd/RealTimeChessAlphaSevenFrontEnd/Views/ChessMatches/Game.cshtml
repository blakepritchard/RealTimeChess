@model RealTimeChessAlphaSevenFrontEnd.Models.ChessMatch


<title>Sprite sheets</title>
<style>
    body {
        background: #dddddd;
    }

    #canvas {
        position: absolute;
        left: 0px;
        top: 20px;
        margin: 20px;
        background: #ffffff;
        border: thin inset rgba(100,150,230,0.5);
        cursor: pointer;
    }

    #readout {
        margin-top: 10px;
        margin-left: 15px;
        color: blue;
    }

    #blacksquare {
        background-color: darkgray;
    }

    #whitesquare {
        background-color: lightgray;
    }
</style>

<div id='readout'></div>
<canvas id='canvas' width='600' height='600'> Canvas not supported </canvas>

<!-- <script src="~/Scripts/realtimechess-0.1.0.js"></script> -->
<script type="text/javascript">

    var canvas = document.getElementById('canvas'),
        context = canvas.getContext('2d'),
        nFontHeight = 15,

        nCellCountX = 8,
        nCellCountY = 8,

        nMarginX = 0,
        nMarginY = 0,

        nCellSizeX = (canvas.width - (2 * nMarginX)) / nCellCountX,
        nCellSizeY = (canvas.height - (2 * nMarginY)) / nCellCountY;

    var isDragging = false;
    var dragStart;
    var dragEnd;

    canvas.addEventListener('mousedown', function (event) {
        dragStart = getMousePosition(event);
        chessMoveStart = getMouseGameLocation(event);
        highlightCell(chessMoveStart.x, chessMoveStart.y);
        var selectedPiece = selectChessPiece(chessMoveStart.x, chessMoveStart.y);
        isDragging = true;
        //context.moveTo(dragStart.x, dragStart.y);
        context.beginPath();
    })

    canvas.addEventListener('mousemove', function (event) {
        if (isDragging)
        {
            dragEnd = getMousePosition(event);
            //context.lineTo(dragEnd.x, dragEnd.y);

        }
    })

    canvas.addEventListener('mouseup', function (event) {
        isDragging = false;
        context.closePath();
        context.stroke();
    })


    // Functions..........................................................
    function drawPointer() {
    }

    function clear() {
        context.clearRect(0, 0, canvas.width, canvas.height);
    }

    function getMousePosition(event) {
        var rect = canvas.getBoundingClientRect();
        return {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top
        }
    }

    function getMouseGameLocation(event) {
        var coordinates = getMousePosition(event);
        return {
            x: Math.floor(coordinates.x / nCellSizeX) + 1,
            y: Math.floor(coordinates.y / nCellSizeY) + 1
        }
    }


    function drawCircle(centerX, centerY, radius) {
        context.beginPath();
        context.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
        context.stroke();
    }


    function drawLabels() {
        var numerals = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], angle = 0, numeralWidth = 0;
        numerals.forEach(function (numeral) {
            angle = Math.PI / 6 * (numeral - 3);
            numeralWidth = context.measureText(numeral).width;
            context.fillText(numeral,
                canvas.width / 2 + Math.cos(angle) * (HAND_RADIUS) - numeralWidth / 2,
                canvas.height / 2 + Math.sin(angle) * (HAND_RADIUS) + nFontHeight / 3);
        });
    }

    function selectChessPiece(nLocationX, nLocationY) {
        var nMatchPlayerId =  @ViewData["MatchPlayerId"];
        var pieces = @Html.Raw(Json.Encode(Model.MatchPlayers.SingleOrDefault(mp => mp.MatchPlayerId == (int)ViewData["MatchPlayerId"]).ChessPieces));

        var pieceSelected = findPieceAtLocation(pieces, nLocationX, nLocationY);
        if (null != pieceSelected) {
            var typeSelected = pieceSelected.ChessPieceType.ChessPieceTypeName;
            console.log("MatchPlayerId=" + nMatchPlayerId + " Selected a: " + typeSelected);
        }
        else {
            console.log("MatchPlayerId=" + nMatchPlayerId + " Could Not Find ChessPiece at Location" + nLocationX + "." + nLocationY);
        }

    }


    // Brute Force Search.
    // There Must Be A Better Way
    function findPieceAtLocation(arrayPieces, nLocationX, nLocationY) {
        var pieceSelected = null;
        for (var i = 0; i<arrayPieces.length; i++) {
            chessPiece = arrayPieces[i];
            if (chessPiece.LocationX == nLocationX && chessPiece.LocationY == nLocationY) {
                pieceSelected = chessPiece;
            }
        }
        return pieceSelected;
    }

    function highlightCell(nCellPositionX, nCellPositionY) {
        // context.clearRect(0, 0, canvas.width, canvas.height);

        // context.lineWidth = "1";
        // context.strokeStyle = "black";

        context.fillStyle = "lightgreen";
        context.beginPath();
        //console.log("Drawing Rectangle, PosX:" + nCellPositionX + ", PosY:" + nCellPositionY);
        context.rect(((nCellPositionX -1)* nCellSizeX), ((nCellPositionY - 1) * nCellSizeY), nCellSizeX, nCellSizeY);
        context.fill();

    }

    function drawBackground() {
        context.clearRect(0, 0, canvas.width, canvas.height);

        context.lineWidth = "1";
        context.strokeStyle = "black";

        //console.log("Cell Size Y=" + nCellSizeY);
        //console.log("Cell Size X=" + nCellSizeX);

        var bCellColor = false
        var nCellPositionY = nMarginY;
        for (var y = 0; y < nCellCountY; y++) {
            //console.log("PositionY=" + nCellPositionY);

            var nCellPositionX = nMarginX;
            for (var x = 0; x < nCellCountX; x++) {
                context.fillStyle = (true === bCellColor) ? "gray" : "darkgray";

                //console.log("PositionX=" + nCellPositionX);

                context.beginPath();
                //console.log("Drawing Rectangle, PosX:" + nCellPositionX + ", PosY:" + nCellPositionY);
                context.rect(nCellPositionX, nCellPositionY, nCellSizeX, nCellSizeY);

                context.fill();
                //context.stroke();

                nCellPositionX += nCellSizeX;
                bCellColor = !bCellColor;
            }
            nCellPositionY += nCellSizeY;
            bCellColor = !bCellColor;
        }
    }

    function drawPieces() {
        var lstPlayers = @Html.Raw(Json.Encode(Model.MatchPlayers));
        var radius = canvas.width / 20;


        for (var p = 0; p < lstPlayers.length; p++) {
            player = lstPlayers[p];

            for (var i = 0; i < player.ChessPieces.length; i++) {
                piece = player.ChessPieces[i];

                var centerX = ((piece.LocationX * nCellSizeX) - (nCellSizeX/2));
                var centerY = ((piece.LocationY * nCellSizeY) - (nCellSizeY/2));

                strColor = player.PlayerType.PlayerTypeName;
                context.strokeStyle = strColor;
                drawCircle(centerX, centerY, radius);


                context.fillStyle = "black";
                context.fillText(piece.ChessPieceType.ChessPieceTypeName, centerX, centerY);
                // console.log(piece.ChessPieceId + ", X:" + piece.LocationX + ", Y:" + piece.LocationY + ", Radius:" + radius);

            }

        }
    }

    function drawGame() {


        // Initialization................................................
        drawBackground();
        drawPieces();
    }



    console.log("test 123");
    drawGame();




</script>
